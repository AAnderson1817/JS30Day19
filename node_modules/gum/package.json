{
  "_args": [
    [
      {
        "raw": "gum",
        "scope": null,
        "escapedName": "gum",
        "name": "gum",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "/Users/NigelFarageMEP/CODE/Tutorials/wesbos/JS30/Day19"
    ]
  ],
  "_from": "gum@latest",
  "_id": "gum@0.0.1",
  "_inCache": true,
  "_location": "/gum",
  "_npmUser": {
    "name": "gozala",
    "email": "rfobic@gmail.com"
  },
  "_npmVersion": "1.1.63",
  "_phantomChildren": {},
  "_requested": {
    "raw": "gum",
    "scope": null,
    "escapedName": "gum",
    "name": "gum",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/gum/-/gum-0.0.1.tgz",
  "_shasum": "9ea0c954bc4cdd79c6b90e04b7db9e22adba985f",
  "_shrinkwrap": null,
  "_spec": "gum",
  "_where": "/Users/NigelFarageMEP/CODE/Tutorials/wesbos/JS30/Day19",
  "author": {
    "name": "Irakli Gozalishvili",
    "email": "rfobic@gmail.com",
    "url": "http://jeditoolkit.com"
  },
  "bugs": {
    "url": "http://github.com/Gozala/gum/issues/"
  },
  "dependencies": {},
  "description": "Small method chaining library",
  "devDependencies": {
    "repl-utils": ">=1.0.0",
    "test": ">=0.4.4"
  },
  "directories": {},
  "dist": {
    "shasum": "9ea0c954bc4cdd79c6b90e04b7db9e22adba985f",
    "tarball": "https://registry.npmjs.org/gum/-/gum-0.0.1.tgz"
  },
  "homepage": "https://github.com/Gozala/gum",
  "id": "gum",
  "keywords": [
    "gum",
    "dsl",
    "composition",
    "chaining"
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/Gozala/gum/License.md"
    }
  ],
  "main": "./gum.js",
  "maintainers": [
    {
      "name": "gozala",
      "email": "rfobic@gmail.com"
    }
  ],
  "name": "gum",
  "optionalDependencies": {},
  "readme": "# gum\n\n[![Build Status](https://secure.travis-ci.org/Gozala/gum.png)](http://travis-ci.org/Gozala/gum)\n\nSmall method chaining library, that can be used to create jQuery like DSLs\nfrom arbitrary functions.\n\n\n## Usage\n\nLets define few utility functions that operate on hashes that we'll create\nDSL for (feel free to skip to a next session)\n\n```js\n\n// General funciton definitions (You can skip this part)\n\nfunction descriptor(source) {\n  return Object.getOwnPropertyNames(source).reduce(function(result, name) {\n    result[name] = Object.getOwnPropertyDescriptor(source, name)\n    return result\n  }, {})\n}\n\nfunction supplement() {\n  var sources = Array.prototype.slice.call(arguments)\n  return merge.apply(merge, sources.reverse())\n}\n\nfunction merge() {\n  var sources = Array.prototype.slice.call(arguments)\n  var whitelist = {}\n  sources.forEach(function(source) {\n    var properties = source ? descriptor(source) : {}\n    Object.keys(properties).forEach(function(name) {\n      whitelist[name] = properties[name]\n    })\n  })\n  return Object.create(Object.getPrototypeOf(sources[0]), whitelist)\n}\n\nfunction pick() {\n  var names = Array.prototype.slice.call(arguments)\n  var source = names.shift()\n  var properties = descriptor(source)\n  var whitelist = {}\n  names.forEach(function(name) {\n    whitelist[name] = properties[name]\n  })\n  return Object.create(Object.getPrototypeOf(source), whitelist)\n}\n```\n\nHash of functions can be used to assemble DSL providing method chaining\ninterface.\n\n```js\nvar gum = require(\"gum\")\nvar hash = gum({ merge: merge, pick: pick, supplement: supplement })\n```\n\nChained operations result in a simple functions that execute chained\ntasks when invoked:\n\n```js\nvar setDefaults = hash.\n    supplement({ x: 0, y: 0 })\n\nsetDefaults()           // => { x: 0, y: 0 }\nsetDefaults({ x: 1 })   // => { x: 1, y: 0 }\n```\n\n\nEach composed function has is aware of the DSL it's part of, so new\ncompostions can be created by further chaining:\n\n```js\nvar adjust = setDefualts.\n  merge({ x: 11, z: 17 }).\n  pick(\"y\", \"z\")\n\nadjust()              // => { y: 0, z: 17 }\nadjust({ y: 15 })     // => { y: 15, z: 17 }\n```\n\nComposed chains could also be bound to the input known up front:\n\n\n```js\nvar value = hash({ a: 1, b: 2, c: 3, d: 4 }).\n  merge({ x: 12, y: 13 }).\n  pick('a', 'b', 'x')\n\nvalue()             // => { x: 12, a: 1, b: 2 }\n```\n\n## Install\n\n    npm install gum\n",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Gozala/gum.git",
    "web": "https://github.com/Gozala/gum"
  },
  "scripts": {
    "repl": "node node_modules/repl-utils",
    "test": "node test/test-all.js"
  },
  "version": "0.0.1"
}
